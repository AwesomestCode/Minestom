package net.minestom.code_generation.blocks;

import com.google.gson.*;
import com.google.gson.stream.JsonReader;
import com.squareup.javapoet.*;
import net.minestom.code_generation.MinestomCodeGenerator;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;

public final class BlockGenerator extends MinestomCodeGenerator {
    private static final Logger LOGGER = LoggerFactory.getLogger(BlockGenerator.class);
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();
    private final File blocksFile;
    private final File blockPropertyFile;
    private final File outputFolder;

    public BlockGenerator(@NotNull File blocksFile, @NotNull File blockPropertyFile, @NotNull File outputFolder) {
        this.blocksFile = blocksFile;
        this.blockPropertyFile = blockPropertyFile;
        this.outputFolder = outputFolder;
    }

    @Override
    public void generate() {
        if (!blocksFile.exists()) {
            LOGGER.error("Failed to find blocks.json.");
            LOGGER.error("Stopped code generation for blocks.");
            return;
        }
        if (!blockPropertyFile.exists()) {
            LOGGER.error("Failed to find block_properties.json.");
            LOGGER.error("Stopped code generation for block properties.");
            return;
        }

        if (!outputFolder.exists() && !outputFolder.mkdirs()) {
            LOGGER.error("Output folder for code generation does not exist and could not be created.");
            return;
        }
        if (!outputFolder.exists() && !outputFolder.mkdirs()) {
            LOGGER.error("Output folder for code generation does not exist and could not be created.");
            return;
        }
        List<JavaFile> filesToWrite = new ArrayList<>();

        // Important classes we use alot
        ClassName blockPropertyCN = ClassName.get("net.minestom.server.instance.block.incubator", "BlockProperty");
        ClassName blockTypeCN = ClassName.get("net.minestom.server.instance.block.incubator", "BlockType");
        ClassName blockImplCN = ClassName.get("net.minestom.server.instance.block.incubator", "BlockImpl");
        ClassName rawBlockDataClassName = ClassName.get("net.minestom.server.raw_data", "RawBlockData");
        ClassName rawBlockStateDataClassName = ClassName.get("net.minestom.server.raw_data", "RawBlockStateData");
        ClassName registryClassName = ClassName.get("net.minestom.server.registry", "Registry");

        JsonArray blockProperties;
        try {
            blockProperties = GSON.fromJson(new JsonReader(new FileReader(blockPropertyFile)), JsonArray.class);
        } catch (FileNotFoundException e) {
            LOGGER.error("Failed to find block_properties.json.");
            LOGGER.error("Stopped code generation for block entities.");
            return;
        }
        ClassName blockPropertiesCN = ClassName.get("net.minestom.server.instance.block.incubator", "BlockProperties");
        // Particle
        TypeSpec.Builder blockPropertiesClass = TypeSpec.classBuilder(blockPropertiesCN)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                // Add @SuppressWarnings("unused")
                .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unused").build())
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName());
        // Add private constructor
        blockPropertiesClass.addMethod(
                MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PRIVATE)
                        .build()
        );
        // This stores the classes of the field names, e.g. WATERLOGGED --> Boolean
        Map<String, Class<?>> propertyMap = new HashMap<>();
        // Use data
        for (JsonElement e : blockProperties) {
            JsonObject blockProperty = e.getAsJsonObject();

            String propertyName = blockProperty.get("name").getAsString();
            JsonArray blockValues = blockProperty.get("values").getAsJsonArray();
            JsonPrimitive firstElement = blockValues.get(0).getAsJsonPrimitive();

            Class<?> type;
            StringBuilder values = new StringBuilder();
            if (firstElement.isBoolean()) {
                type = Boolean.class;
                values = new StringBuilder("true, false");
            } else if (firstElement.isNumber()) {
                type = Integer.class;
                for (JsonElement blockValue : blockValues) {
                    int i = blockValue.getAsInt();
                    values.append(i).append(", ");
                }
                // Delete final ', '
                values.delete(values.lastIndexOf(","), values.length());
            } else {
                type = String.class;
                for (JsonElement blockValue : blockValues) {
                    String s = blockValue.getAsString();
                    values.append("\"").append(s).append("\", ");
                }
                // Delete final ', '
                values.delete(values.lastIndexOf(","), values.length());
            }

            propertyMap.put(propertyName, type);
            // Adds the field to the main class
            // e.g. BlockProperty<Boolean> WATERLOGGED = new BlockProperty<Boolean>("waterlogged", true, false)
            blockPropertiesClass.addField(
                    FieldSpec.builder(
                            ParameterizedTypeName.get(blockPropertyCN, TypeName.get(type)),
                            propertyName
                    ).initializer(
                            "new $T<>($S, $L)",
                            blockPropertyCN,
                            blockProperty.get("key").getAsString(),
                            values
                    ).addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL).build()
            );
        }

        JsonArray blocks;
        try {
            blocks = GSON.fromJson(new JsonReader(new FileReader(blocksFile)), JsonArray.class);
        } catch (FileNotFoundException e) {
            LOGGER.error("Failed to find blocks.json.");
            LOGGER.error("Stopped code generation for blocks.");
            return;
        }
        ClassName blocksCN = ClassName.get("net.minestom.server.instance.block.incubator", "Blocks");
        // Blocks class
        TypeSpec.Builder blocksClass = TypeSpec.classBuilder(blocksCN)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName());
        // Add private constructor
        blocksClass.addMethod(
                MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PRIVATE)
                        .build()
        );
        // Use data
        for (JsonElement b : blocks) {
            JsonObject block = b.getAsJsonObject();

            String blockName = block.get("name").getAsString();
            // Handle the properties
            // Create a subclass for each Block and reference the main BlockProperty.
            {
                JsonArray properties = block.get("properties").getAsJsonArray();
                if (properties.size() != 0) {
                    // Create a subclass called "blockName"
                    // e.g. subclass AIR in BlockProperties
                    TypeSpec.Builder subClass = TypeSpec.classBuilder(blockPropertiesCN.nestedClass(blockName))
                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
                    // Store a list of values for the getProperties() method.
                    StringBuilder values = new StringBuilder();
                    // Go through all properties the block has.
                    for (JsonElement property : properties) {
                        String propertyName = property.getAsString();
                        // Add a static field that delegates to the BlockProperties static definition
                        subClass.addField(
                                FieldSpec.builder(
                                        ParameterizedTypeName.get(blockPropertyCN, TypeName.get(propertyMap.get(propertyName))),
                                        propertyName
                                ).initializer(
                                        "$T.$N",
                                        blockPropertiesCN,
                                        propertyName
                                ).addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL).build()
                        );
                        values.append(propertyName).append(", ");
                    }
                    // Delete final ', '
                    values.delete(values.lastIndexOf(","), values.length());
                    // Add a static method to get all the properties
                    subClass.addMethod(
                            MethodSpec.methodBuilder("getProperties")
                                    .returns(
                                            // List<BlockProperty<?>>
                                            ParameterizedTypeName.get(
                                                    ClassName.get(List.class),
                                                    // BlockProperty<?>
                                                    ParameterizedTypeName.get(blockPropertyCN, TypeVariableName.get("?"))
                                            )
                                    )
                                    .addStatement(
                                            "return $T.of($L)",
                                            // If it has multiple properties --> Arrays.asList() else Collections.singletonList()
                                            ClassName.get(List.class),
                                            values
                                    )
                                    .addModifiers(Modifier.STATIC)
                                    .build()
                    );

                    blockPropertiesClass.addType(subClass.build());
                }
            }


            blocksClass.addField(
                    FieldSpec.builder(blockTypeCN, blockName)
                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
//                            .initializer("new $T")
                            .build()
            );

            JsonArray states = block.get("states").getAsJsonArray();

        }


        filesToWrite.add(
                JavaFile.builder("net.minestom.server.instance.block.incubator", blocksClass.build())
                        .indent("    ")
                        .skipJavaLangImports(true)
                        .build()
        );
        writeFiles(
                Collections.singletonList(
                        JavaFile.builder("net.minestom.server.instance.block.incubator", blockPropertiesClass.build())
                                .indent("    ")
                                .skipJavaLangImports(true)
                                .build()
                ),
                outputFolder
        );

        // Write files to outputFolder
        writeFiles(filesToWrite, outputFolder);
    }
}
