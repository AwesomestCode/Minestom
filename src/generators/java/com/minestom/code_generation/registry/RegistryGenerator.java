package com.minestom.code_generation.registry;

import com.minestom.code_generation.MinestomCodeGenerator;
import com.minestom.code_generation.blocks.BlockGenerator;
import com.squareup.javapoet.*;
import it.unimi.dsi.fastutil.Pair;
import it.unimi.dsi.fastutil.objects.ObjectReferenceImmutablePair;
import net.minestom.server.utils.NamespaceID;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.io.File;
import java.lang.annotation.Annotation;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public final class RegistryGenerator extends MinestomCodeGenerator {
    private static final Logger LOGGER = LoggerFactory.getLogger(BlockGenerator.class);
    // List of registeries.
    @SuppressWarnings("unchecked")
    private static final Pair<ClassName, String>[] registries = new Pair[]{
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.instance", "Block"), "AIR"),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.fluid", "Fluid"), "EMPTY"),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.item", "Material"), "AIR"),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.item", "Enchantment"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.attribute", "Attribute"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.entity", "EntityType"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.particle", "Particle"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.potion", "PotionType"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.potion", "PotionEffect"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.sound", "SoundEvent"), null),
            new ObjectReferenceImmutablePair<>(ClassName.get("net.minestom.server.statistic", "StatisticType"), null)
    };
    private final File outputFolder;

    public RegistryGenerator() {
        this(null);
    }

    public RegistryGenerator(@Nullable File outputFolder) {
        this.outputFolder = Objects.requireNonNullElse(outputFolder, DEFAULT_OUTPUT_FOLDER);

    }

    @Override
    public void generate() {
        // Important classes we use alot
        ClassName namespaceIDClassName = ClassName.get("net.minestom.server.utils", "NamespaceID");
        ClassName keyIDClassName = ClassName.get("net.kyori.adventure.key", "Key");

        // Registry class
        ClassName registeriesClassName = ClassName.get("net.minestom.server.registry", "Registries");

        TypeSpec.Builder registriesClass = TypeSpec.classBuilder(registeriesClassName)
                .addModifiers(Modifier.PUBLIC).addModifiers(Modifier.FINAL)
                .addJavadoc("AUTOGENERATED");


        FieldSpec[] registryFields = new FieldSpec[registries.length];
        FieldSpec[] simpleRegistryFields = new FieldSpec[registries.length];
        // Hashmaps
        for (int i = 0; i < registries.length; i++) {
            ClassName type = registries[i].first();

            FieldSpec registryField = FieldSpec.builder(
                    ParameterizedTypeName.get(
                            ClassName.get(Map.class),
                            ClassName.get(NamespaceID.class),
                            type
                    ),
                    decapitalizeString(type.simpleName()) + "Registry" // e.g. blockRegistry, potionEffectRegistry
            )
                    .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                    .initializer("new $T<>()", ClassName.get(ConcurrentHashMap.class))
                    .build();
            FieldSpec simpleRegistryField = FieldSpec.builder(
                    ParameterizedTypeName.get(
                            ClassName.get(List.class),
                            type
                    ),
                    decapitalizeString(type.simpleName()) + "SimpleRegistry" // e.g. blockSimpleRegistry, potionEffectSimpleRegistry
            )
                    .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
                    .initializer("new $T<>()", ClassName.get(ArrayList.class))
                    .build();

            registryFields[i] = registryField;
            registriesClass.addField(registryField);

            simpleRegistryFields[i] = simpleRegistryField;
            registriesClass.addField(simpleRegistryField);
        }

/*
            // Get examples:
            /** Returns 'AIR' if none match
            public static Block getBlock(String id) {
                return getBlock(NamespaceID.from(id));
            }

            /** Returns 'AIR' if none match
            public static Block getBlock(NamespaceID id) {
                return blocks.getOrDefault(id, AIR);
            }
            // Add examples:
            public static boolean addBlock(NamespaceID id, Block block) {
                // ensure the block is not already there (map.values.contains()) (return false if already there)
                // ensure the namespace is not already there (map.keySet.contains()) (return false if already there)
                // add to block registry hashmap. (return true)
            }
 */

        for (int i = 0; i < registries.length; i++) {
            ClassName type = registries[i].first();
            String defaultValue = registries[i].second();
            FieldSpec registryField = registryFields[i];
            FieldSpec simpleRegistryField = simpleRegistryFields[i];
            String typeName = type.simpleName();

            ParameterSpec namespaceIDParam = ParameterSpec.builder(namespaceIDClassName, "id").addAnnotation(NotNull.class).build();
            ParameterSpec keyIDParam = ParameterSpec.builder(keyIDClassName, "key").addAnnotation(NotNull.class).build();
            ParameterSpec stringIDParam = ParameterSpec.builder(ClassName.get(String.class), "id").addAnnotation(NotNull.class).build();


            // Getting
            {
                // code
                CodeBlock.Builder code = CodeBlock.builder();
                Class<? extends Annotation> annotation;
                if (defaultValue != null) {
                    annotation = NotNull.class;
                    code.addStatement("return $N.getOrDefault($N, $T.$N)", registryField, namespaceIDParam, type, defaultValue);
                } else {
                    annotation = Nullable.class;
                    code.addStatement("return $N.get($N)", registryField, namespaceIDParam);
                }
                // javadoc
                StringBuilder javadoc = new StringBuilder("Returns the corresponding ");
                javadoc.append(typeName).append(" matching the given id. Returns ");
                if (defaultValue != null) {
                    javadoc.append('\'').append(defaultValue).append('\'');
                } else {
                    javadoc.append("null");
                }
                javadoc.append(" if none match.");

                // string variant
                MethodSpec idMethod = MethodSpec.methodBuilder("get" + typeName)
                        .returns(type)
                        .addAnnotation(annotation)
                        .addParameter(stringIDParam)
                        .addStatement("return get$N(NamespaceID.from($N))", typeName, stringIDParam)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addJavadoc(javadoc.toString())
                        .build();
                registriesClass.addMethod(idMethod);

                // NamespaceID variant
                registriesClass.addMethod(MethodSpec.methodBuilder("get" + typeName)
                        .returns(type)
                        .addAnnotation(annotation)
                        .addParameter(namespaceIDParam)
                        .addCode(code.build())
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addJavadoc(javadoc.toString())
                        .build());

                // Key variant
                registriesClass.addMethod(MethodSpec.methodBuilder("get" + typeName)
                        .returns(type)
                        .addAnnotation(annotation)
                        .addParameter(keyIDParam)
                        .addStatement("return get$N(NamespaceID.from($N))", typeName, keyIDParam)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addJavadoc(javadoc.toString().replace(" id.", " key."))
                        .build());
            }
            // Registering
            {
                ParameterSpec typeParam = ParameterSpec.builder(type, typeName.toLowerCase()).addAnnotation(NotNull.class).build();
                // code
                CodeBlock.Builder code = CodeBlock.builder();
                // check if key already exists
                code.beginControlFlow("if ($N.containsKey($N))", registryField, namespaceIDParam);
                code.addStatement("return false");
                code.endControlFlow();
                // check if value already exists
                code.beginControlFlow("if ($N.containsValue($N))", registryField, typeParam);
                code.addStatement("return false");
                code.endControlFlow();
                // Add value to hashmap
                code.addStatement("$N.put($N, $N)", registryField, namespaceIDParam, typeParam);
                code.addStatement("$N.add($N)", simpleRegistryField, typeParam);
                code.addStatement("return true");

                // javadoc
                StringBuilder javadoc = new StringBuilder("Adds the given ");
                javadoc.append(typeName).append(" to the registiry with the given id. ");
                javadoc.append("Returns false if the ").append(typeName).append(" or the id is already registered.");

                // string variant
                registriesClass.addMethod(MethodSpec.methodBuilder("register" + typeName)
                        .returns(TypeName.BOOLEAN)
                        .addParameter(stringIDParam)
                        .addParameter(typeParam)
                        .addStatement("return register$N(NamespaceID.from($N), $N)", typeName, stringIDParam, typeParam)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addJavadoc(javadoc.toString())
                        .build()
                );

                // NamespaceID variant
                registriesClass.addMethod(MethodSpec.methodBuilder("register" + typeName)
                        .returns(TypeName.BOOLEAN)
                        .addParameter(namespaceIDParam)
                        .addParameter(typeParam)
                        .addCode(code.build())
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addJavadoc(javadoc.toString())
                        .build()
                );

                // Key variant
                registriesClass.addMethod(MethodSpec.methodBuilder("register" + typeName)
                        .returns(TypeName.BOOLEAN)
                        .addParameter(keyIDParam)
                        .addParameter(typeParam)
                        .addStatement("return register$N(NamespaceID.from($N), $N)", typeName, keyIDParam, typeParam)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addJavadoc(javadoc.toString().replace(" id\\.", " key."))
                        .build()
                );
            }

            // getNumericalId & fromNumericalId methods
            {
                registriesClass.addMethod(MethodSpec.methodBuilder("get" + typeName + "NumericalId")
                        .returns(TypeName.INT)
                        .addParameter(ParameterSpec.builder(type, typeName.toLowerCase()).addAnnotation(NotNull.class).build())
                        .addStatement(
                                "return $N.indexOf(" + typeName.toLowerCase() + ")",
                                simpleRegistryField
                        )
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .build()
                );
                registriesClass.addMethod(MethodSpec.methodBuilder("from" + typeName + "NumericalId")
                        .returns(type).addAnnotation(Nullable.class)
                        .addParameter(TypeName.INT, "id")
                        .beginControlFlow("try")
                        .addStatement(
                                "return $N.get(id)",
                                simpleRegistryField
                        )
                        .nextControlFlow("catch ($T e)", ClassName.get(IndexOutOfBoundsException.class))
                        .addStatement("return null")
                        .endControlFlow()
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .build()
                );
            }
        }

        // Write files to outputFolder
        writeFiles(
                Collections.singletonList(
                        JavaFile.builder("net.minestom.server.registry", registriesClass.build()).build()
                ),
                outputFolder
        );
    }
}
